## 目标

我需要使用 fastapi mcp 开发一个渐进式执行 api 的工具，你需要帮我开发一个mcp server 端，支持五个工具:
1. 初始化会话（设置 app_id）
2. 获取分类列表
3. 根据分类列表获取API列表(仅仅是API名称以及描述)
4. 根据API列表获取API信息，包括输入参数定义
5. 执行多个API结果

## 会话管理

### 设计原则

- **会话状态**: 每个 MCP 会话维护独立的上下文，包括 app_id 和缓存
- **一次初始化**: app_id 仅在会话初始化时设置一次
- **自动获取**: 所有工具调用自动从会话上下文中获取 app_id，无需显式传递
- **会话隔离**: 不同会话之间的 app_id 和缓存完全隔离

## 工具说明

### 1. 初始化会话 (initialize_session)

**功能描述**: 初始化 MCP 会话，设置 app_id 到会话上下文中

**输入参数**:
- `app_id` (string, required): 应用标识符

**输出结果**:
```json
{
  "success": true,
  "message": "Session initialized successfully",
  "app_id": "string"
}
```

**说明**:
- 此工具必须在使用其他工具之前调用
- app_id 会被保存在会话上下文中，后续工具调用自动使用
- 如果会话已初始化，重复调用会更新 app_id

### 2. 获取分类列表 (get_categories)

**功能描述**: 获取当前会话 app_id 下所有可用的 API 分类列表

**输入参数**: 无（自动从会话上下文获取 app_id）

**输出结果**:
```json
{
  "categories": [
    {
      "id": "string",
      "name": "string",
      "description": "string"
    }
  ]
}
```

**缓存策略**: 可缓存，缓存时间建议 1 小时

### 3. 根据分类获取API列表 (get_apis_by_category)

**功能描述**: 根据指定的分类 ID，获取该分类下所有 API 的基本信息（名称和描述）

**输入参数**:
- `category_id` (string, required): 分类 ID

**输出结果**:
```json
{
  "apis": [
    {
      "name": "string",
      "description": "string",
      "category_id": "string"
    }
  ]
}
```

**说明**:
- 自动从会话上下文获取 app_id
- API 名称在同一个 app_id 下是唯一的

**缓存策略**: 可缓存，缓存时间建议 1 小时

### 4. 获取API详细信息 (get_api_details)

**功能描述**: 根据一个或多个 API 名称获取这些 API 的详细信息，包括输入参数定义、输出格式等

**输入参数**:
- `api_names` (array, required): API 名称列表，支持批量获取

**输出结果**:
```json
{
  "apis": [
    {
      "name": "string",
      "description": "string",
      "category_id": "string",
      "parameters": [
        {
          "name": "string",
          "type": "string|number|boolean|object|array",
          "required": true|false,
          "description": "string",
          "default": "any"
        }
      ],
      "response_schema": {
        "type": "object",
        "properties": {}
      }
    }
  ]
}
```

**说明**:
- 自动从会话上下文获取 app_id
- 在同一个 app_id 下，API 名称是唯一的

**缓存策略**: 可缓存，缓存时间建议 1 小时

### 5. 执行API (execute_apis)

**功能描述**: 执行一个或多个 API 调用，支持批量执行

**输入参数**:
- `executions` (array, required): API 执行列表
  ```json
  [
    {
      "api_name": "string",
      "parameters": {
        "key": "value"
      }
    }
  ]
  ```

**输出结果**:
```json
{
  "results": [
    {
      "api_name": "string",
      "success": true|false,
      "data": {},
      "error": "string|null"
    }
  ]
}
```

**说明**:
- 自动从会话上下文获取 app_id
- 使用 API 名称而非 ID，因为在同一个 app_id 下 API 名称是唯一的

**缓存策略**: 不缓存（实时执行）

## 设计思想

### 为什么渐进式

1. **API 数量众多**: 当系统中存在大量 API 时，一次性加载所有 API 信息会导致上下文过大
2. **按需加载**: 大模型可以根据用户需求，逐步探索和获取相关 API 信息
3. **降低延迟**: 分步获取可以更快地响应用户，提升交互体验
4. **智能筛选**: 大模型可以根据分类和描述，智能选择最相关的 API

### 约束条件

1. **有状态设计**: MCP Client 连接时需要传入 `app_id`，用于标识不同的应用系统
2. **会话隔离**: 每个 MCP 会话维护独立的 app_id、状态和缓存
3. **权限控制**: 不同的 app_id 可能有不同的 API 访问权限
4. **API 名称唯一性**: 在同一个 app_id 下，API 名称是唯一的，因此使用 API 名称而非 ID 作为标识符

### 缓存策略

1. **分类列表缓存**: 缓存时间 1 小时，减少重复查询
2. **API 列表缓存**: 按分类缓存，缓存时间 1 小时
3. **API 详情缓存**: 按 API ID 缓存，缓存时间 1 小时
4. **执行结果不缓存**: API 执行结果实时返回，不做缓存

## 技术架构

### 技术栈

- **框架**: FastAPI (Python 3.9+)
- **MCP SDK**: mcp Python SDK
- **缓存**: 内存缓存 (可扩展为 Redis)
- **HTTP 客户端**: httpx (支持异步)

### 目录结构

```
mcp_data_api/
├── server.py           # MCP Server 主入口
├── session.py          # 会话管理
├── tools/              # 工具实现
│   ├── __init__.py
│   ├── initialize.py   # 会话初始化工具
│   ├── categories.py   # 分类相关工具
│   ├── apis.py         # API 相关工具
│   └── executor.py     # API 执行工具
├── cache/              # 缓存模块
│   ├── __init__.py
│   └── memory_cache.py
├── models/             # 数据模型
│   ├── __init__.py
│   ├── category.py
│   ├── api.py
│   └── execution.py
├── config.py           # 配置管理
└── requirements.txt    # 依赖包
```

## 数据模型

### SessionContext (会话上下文)

```python
class SessionContext:
    app_id: Optional[str]
    cache: MemoryCache
    initialized: bool
```

### Category (分类)

```python
class Category:
    id: str
    name: str
    description: str
```

### API (API 信息)

```python
class API:
    name: str  # 在同一个 app_id 下唯一
    description: str
    category_id: str
    parameters: List[Parameter]
    response_schema: dict
```

### Parameter (参数)

```python
class Parameter:
    name: str
    type: str  # string, number, boolean, object, array
    required: bool
    description: str
    default: Any
```

### ExecutionRequest (执行请求)

```python
class ExecutionRequest:
    api_name: str
    parameters: dict
```

### ExecutionResult (执行结果)

```python
class ExecutionResult:
    api_name: str
    success: bool
    data: Any
    error: Optional[str]
```

## 错误处理

### 错误类型

1. **初始化错误**: app_id 无效或缺失
2. **分类不存在**: 指定的 category_id 不存在
3. **API 不存在**: 指定的 api_id 不存在
4. **参数错误**: 必需参数缺失或参数类型不匹配
5. **执行失败**: API 调用失败（网络错误、超时、服务端错误等）
6. **权限错误**: 当前 app_id 无权访问指定的 API

### 错误响应格式

```json
{
  "error": {
    "code": "string",
    "message": "string",
    "details": {}
  }
}
```

## 安全考虑

1. **app_id 验证**: 验证 MCP Client 传入的 app_id 是否有效和授权
2. **API 密钥管理**: 后端 API 的密钥应通过环境变量或配置文件管理
3. **参数验证**: 严格验证所有输入参数，防止注入攻击
4. **速率限制**: 对 API 执行工具实施速率限制，防止滥用
5. **日志记录**: 记录所有 API 调用和 app_id，便于审计和问题排查
6. **超时控制**: 设置合理的 API 调用超时时间，防止长时间阻塞

## 实现细节

### 初始化流程

1. MCP Server 启动时，初始化缓存模块和会话管理器
2. 注册五个工具到 MCP Server
3. MCP Client 连接后，首次调用 `initialize_session` 工具传入 app_id
4. MCP Server 将 app_id 保存到会话上下文中
5. 后续所有工具调用自动从会话上下文获取 app_id，无需显式传递

### 会话上下文管理

```python
class SessionContext:
    def __init__(self):
        self.app_id: Optional[str] = None
        self.cache: MemoryCache = MemoryCache()
        self.initialized: bool = False

    def initialize(self, app_id: str):
        self.app_id = app_id
        self.initialized = True

    def get_app_id(self) -> str:
        if not self.initialized:
            raise Exception("Session not initialized. Call initialize_session first.")
        return self.app_id
```

### 缓存实现

```python
class MemoryCache:
    def __init__(self, ttl: int = 3600):
        self.cache = {}
        self.ttl = ttl

    def get(self, key: str) -> Optional[Any]:
        # 检查是否过期
        # 返回缓存值
        pass

    def set(self, key: str, value: Any):
        # 设置缓存值和过期时间
        pass
```

### API 执行流程

1. 接收执行请求列表
2. 并发执行多个 API 调用（使用 asyncio）
3. 收集所有执行结果
4. 返回统一的结果列表

## 扩展性

### 未来可扩展功能

1. **API 搜索**: 支持按关键词搜索 API
2. **API 依赖**: 支持 API 之间的依赖关系和链式调用
3. **结果转换**: 支持将一个 API 的输出作为另一个 API 的输入
4. **批量操作**: 支持批量创建、更新、删除操作
5. **Webhook 支持**: 支持异步 API 调用和 Webhook 回调
6. **多数据源**: 支持从多个数据源聚合 API 信息

## 使用示例

### 场景 1: 查找并执行用户相关 API

```
1. 用户: "帮我查询用户信息"
2. LLM 调用: initialize_session(app_id="my_app") -> 初始化会话
3. LLM 调用: get_categories() -> 获取所有分类
4. LLM 分析: 找到 "用户管理" 分类
5. LLM 调用: get_apis_by_category(category_id="user_management")
6. LLM 分析: 找到 "获取用户信息" API (名称: "get_user_info")
7. LLM 调用: get_api_details(api_names=["get_user_info"])
8. LLM 分析: 需要 user_id 参数
9. LLM 询问: "请提供用户 ID"
10. 用户: "12345"
11. LLM 调用: execute_apis([{api_name: "get_user_info", parameters: {user_id: "12345"}}])
12. LLM 返回: 用户信息结果
```

### 场景 2: 批量执行多个 API

```
1. 用户: "帮我获取用户信息和订单列表"
2. LLM 调用: initialize_session(app_id="my_app") -> 初始化会话
3. LLM 通过渐进式探索找到两个 API
4. LLM 调用: execute_apis([
     {api_name: "get_user_info", parameters: {user_id: "12345"}},
     {api_name: "get_orders", parameters: {user_id: "12345"}}
   ])
5. LLM 返回: 合并后的结果
```

### 场景 3: 会话已初始化的情况

```
1. 用户: "查询订单详情"
2. LLM 检查: 会话已初始化（app_id 已存在）
3. LLM 直接调用: get_categories() -> 无需再次初始化
4. LLM 继续后续操作...
```

## 测试策略

### 单元测试

1. **工具测试**: 测试每个工具的输入输出
2. **缓存测试**: 测试缓存的设置、获取、过期逻辑
3. **模型测试**: 测试数据模型的序列化和反序列化

### 集成测试

1. **端到端测试**: 模拟完整的 API 探索和执行流程
2. **并发测试**: 测试多个 API 并发执行的正确性
3. **错误处理测试**: 测试各种错误场景的处理

### 性能测试

1. **缓存性能**: 测试缓存命中率和响应时间
2. **并发性能**: 测试高并发场景下的性能表现
3. **大数据量测试**: 测试大量 API 和分类的场景

## 部署说明

### 环境要求

- Python 3.9+
- 内存: 至少 512MB
- 网络: 需要访问目标 API 服务

### 配置文件

```yaml
# config.yaml
api_base_url: "https://api.example.com"
cache:
  enabled: true
  ttl: 3600
  type: "memory"  # 或 "redis"
rate_limit:
  enabled: true
  max_requests_per_minute: 60
timeout:
  api_call: 30  # 秒
logging:
  level: "INFO"
  file: "mcp_server.log"
```

**注意**: `app_id` 由 MCP Client 在连接时传入，不在服务端配置文件中配置

### 启动命令

```bash
# 安装依赖
pip install -r requirements.txt

# 启动 MCP Server
python server.py --config config.yaml
```

### Docker 部署

```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["python", "server.py"]
```

## 监控和日志

### 日志内容

1. **API 调用日志**: 记录每次 API 调用的参数和结果
2. **错误日志**: 记录所有错误和异常
3. **性能日志**: 记录响应时间和缓存命中率

### 监控指标

1. **请求量**: 每个工具的调用次数
2. **成功率**: API 执行的成功率
3. **响应时间**: 平均响应时间和 P95/P99
4. **缓存命中率**: 缓存的命中率
5. **错误率**: 各类错误的发生率

## 开发计划

### Phase 1: 核心功能 (MVP)

- [ ] 实现会话管理机制
- [ ] 实现五个基本工具（初始化、分类、API列表、API详情、执行）
- [ ] 实现内存缓存
- [ ] 基本错误处理
- [ ] 单元测试

### Phase 2: 优化和增强

- [ ] 添加 Redis 缓存支持
- [ ] 实现速率限制
- [ ] 完善错误处理和日志
- [ ] 集成测试和性能测试

### Phase 3: 高级功能

- [ ] API 搜索功能
- [ ] API 依赖和链式调用
- [ ] Webhook 支持
- [ ] 监控和告警 